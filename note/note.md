[TOC]

https://www.cnblogs.com/dpSolitude/

# 操作系统引论

操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充

操作系统的主要目的是：方便性、有效性、可扩充性、开放性

- 方便性：未配置os的计算机极难使用，os提供各种操作命令操纵计算机

- 提高资源利用率，提高系统吞吐量，有效组织计算机工作流程

- 可扩充性：适应计算机硬件、体系结构、计算机应用发展。微内核

- 系统遵循世界标准。

  

操作系统的作用

- 作为用户与计算机硬件之间的接口：用户通过命令方式、系统调用、图标—窗口方式来操作计算机
- 计算机系统资源管理者：资源主要分为四类：处理机、存储器、I/O设备以及文件。
- 对计算机资源的抽象：用户无需关心硬件接口的具体实现



操作系统的特征

- 并发
- 共享
- 虚拟
- 异步：导致进程的结果与时间有关



未配置操作系统的计算机：

1. ​	人工操作
   - 用户独占全机
   - cpu等待人工操作
2.  脱机输入/输出方式
   - 减少cpu空闲时间
   - 提高IO速度



单道批处理系统：

1. 处理过程
   - 将一批作业以脱机方式输入到磁带上
   - 监督程序将磁带上第一个作业调入内存
   - 监督程序将cpu控制权交给该作业
   - 作业完成后将控制权交给监督程序
   - 内存中始终保持一道作业
2. 缺点
   - 系统中的资源得不到充分使用，因为内存中只有一道作业，当作业发出IO请求时，cpu便处于等待状态
   - 浪费内存空间，为了可以运行大型作业，一般配置较大内存，但大部分作业都是小型作业
3. 特点
   - 自动性
   - 顺序性
   - 单道性



多道批处理系统

1. 基本概念

   为进一步提高资源利用率和系统吞吐量。用户提交的作业先存放在外存上并成一个队列，称为“后备队列”。按照一定的调度算法从中选取若干调入内存中。

2. 优点

   - 资源利用率高，可交替运行，提高cpu和io利用率
   - 系统吞吐量大，让cpu和其他资源保持忙碌状态，仅当作业完成或者完成不下去时切换，系统开销小

3. 缺点

   - 平均周转时间长。因为需要排队处理
   - 无交互能力

4. 需要解决的问题

   - 处理机争用问题
   - 内存分配和保护问题
   - IO设备分配问题
   - 作业管理问题
   - 用户与系统接口问题

5. 特点

   - 多道

   - 宏观上并行

   - 微观串行

     



分时系统

1. 引入原因
   - 人机交互。
   - 共享主机
2. 需解决问题
   - 多道批处理系统中无法交互的原因是作业都先驻留在外存中，即便被调入内存也要等待才能执行
   - 及时接收。配置多路卡，实现分时多路复用，主机周期快速扫描各个终端，为每个终端配置缓冲区暂存命令
   - 及时处理。作业直接存入内存中，采用轮转方式调度。
3. 特征
   - 多路性：指可以将多台终端同时连接到一台主机上，并分时为每个用户服务。这允许多个用户同时使用计算机，显著提高资源利用率
   - 独立性：每个用户之间相互不干扰
   - 及时性：用户请求可以在短时间内响应
   - 交互性：用户可以请求系统提供多方面服务



实时系统

1. 任务类型
   - 周期性任务和非周期性任务。为周期任务存在开始截止时间和结束截止时间
   - 硬实时任务和软实时任务。硬实时系统指一定要在截止时间内完成的任务。软实时任务是指即使超过一点时间也没有关系，入信息查询系统和多媒体系统
2. 与分时系统比较
   - 多路性：实时系统多路性指系统周期对多路现场采集。
   - 独立性：
   - 及时性：
   - 可靠性：采取多级容错来保障系统的安全性



单用户单任务操作系统

只允许一个用户上机，允许用户程序作为一个任务运行。代表CP/M和MS-DOS



单用户多任务操作系统

只允许一个用户上机，允许将用户程序分为若干个任务并发执行。代表window xp



多用户多任务操作系统

允许多个用户通过终端连接一台机器，共享主机内各种资源，它们可以并发执行。代表linux



操作系统的主要功能

1. 处理机管理功能

   - 进程控制：在多道程序环境下使作业可以并发执行，为作业创建、终止、转换状态

   - 进程同步：

   - 进程通信：使用消息队列
   - 调度：作业调度、进程调度

2. 存储器管理功能

   - 内存分配：为程序分配空间，提高存储器利用率，减少碎片、允许正在运行的程序附加额外空间
   - 内存保护：保证用户程序都仅在自己的内存中运行，彼此不相互干扰，不允许用户程序访问系统程序和数据和转移到非共享
   - 地址映射：在硬件支持下完成
   - 内存扩充：借助虚拟存储技术

3. 设备管理功能

   - 缓冲管理：在io设备和cpu中使用缓冲
   - 设备分配：
   - 设备处理

4. 文件管理功能

   - 文件存储空间管理：系统设置相应的数据结构管理文件的分配回收
   - 目录管理：
   - 文件读写和保护：



操作系统与用户间的接口

1. 用户接口（命令接口）

   - 联机用户接口：由键盘操作命令和解释程序组成
   - 脱机用户接口：为批处理用户准备。用户作业控制语言JCL将对作业的控制和干预事先写出再一起交给处理机
   - 图形用户接口

2. 程序接口

   - 系统调用：是提供给编程用户的唯一接口
   - 库函数

   

   现代操作系统新功能

   1. 系统安全
   2. 网络功能和服务
   3. 支持多媒体

   

   操作系统的结构

   传统结构：无结构（第一代）、模块化（第二代）、分层式（第三代）

   现代结构：微内核结构

   

   

   通道是一种硬件技术

   用户从用户态转为内核态是由硬件实现的
   
   中断时PC由中断隐指令（硬件自动）保存，通用寄存器由操作系统保存

   

   微内核优点

   - 添加服务不必修改内核
   - 系统更可靠，因为内容少
   - 可移植性
   - 适合分布式、多处理机
   
   微内核缺点
   
   - 效率更低，切换内核频繁
   
   微内核基本功能
   
   - 进程管理
   - 低级存储器管理
   - 中断和陷入管理
   
   
   
   用户态到核心态通过中断实现，核心态到用户态通过特权指令实现
   
   陷入指令（管访指令）只能在用户态使用，使用后进入核心态
   
   
   
   操作系统的引导
   
   1. 激活cpu，cpu从rom中读取boot程序，将pc置为bios的第一条指令
   2. 硬件自检
   3. 加载带有操作系统的硬盘
   4. 加载主引导区mbr
   5. 扫描硬盘分区表
   6. 加载分区引导记录pbr
   7. 加载启动管理器
   8. 加载操作系统
   
   
   
   # 程序描述与控制
   
   作业是从用户角度出发，进程是从系统角度出发
   
   中断向量是中断程序的入口地址
   
   
   
   并发带来的新特征
   
   1. 间断性。相互制约导致并发程序具有“执行—暂停—执行”间断运行的活动规律
   2. 失去封闭性。进程占有全部资源。程序的执行的结果不单单与自身有关，还与其他程序有关
   3. 不可再现性。
   
   执行结果与程序执行速度有关
   
   
   
   为了能够对并发程序加以描述与控制，引入进程概念
   
   进程实体由程序段、相关数据段和PBC组成
   
   创建进程实体的本质是创建PCB，撤销进程的实质是撤销PCB
   
   
   
   进程的定义
   
   - 进程是程序的一次执行
   - 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
   - 进程是具有独立功能的程序在一个数据集上运动的过程，它是系统进行资源分配和调度的一个独立单位
   
   
   
   进程的特征
   
   - 动态性：进程的实质就是进程实体执行过程
   - 并发性
   - 独立性
   - 异步性
   
   
   
   
   
   进程的三种基本状态
   
   - 就绪：进程已经获得除cpu外的所有资源，只用获取cpu就可以执行
   - 执行：这在被cpu执行
   - 阻塞：正在执行的进程由于发生某事件（io请求、申请缓冲区失败）暂时无法继续执行的状态
   
   
   
   ```mermaid
   graph LR;
   就绪 --进程调度--> 执行 --IO请求--> 阻塞 --io完成--> 就绪
   执行 --时间片完--> 就绪
   ```
   
   创建状态
   
   - 申请一个空白的pcb
   - 向pcb中填入控制和管理进程信息
   - 为进程分配所需的资源
   - 将进程转入就绪状态并插入就绪队列中
   
   
   
   终止状态
   
   - 等待操作系统善后工作
   - 将pcb清空
   - 将pcb空间返还
   
   
   
   ```mermaid
   graph LR;
   创建--许可-->就绪--进程调度-->执行--释放-->终止
   执行--时间片完-->就绪
   执行--io请求-->阻塞
   阻塞--io完成-->就绪
   
   ```

   
   
   os管理的数据分为四种
   
   - 内存表
   - 设备表
   - 文件表
   - 进程表
   
   
   
   pcb的作用是使在多道程序环境下不能独立运行的程序成为一个能够独立运行的基本单位，能与其他进程并发执行的进程。
   
   - 作为独立运行基本单位的标志。当一个进程配备pbc后就成为一个可以独立运行的基本单位
   - 实现以间断方式运行。在运行中断时可以将cpu现场信息保存在pbc中，在重新运行进程时可以将保存的信息恢复
   - 提供进程调度的信息
   - 实现与其他进程的通信与同步
   
   
   
   pbc中的信息
   
   1. 进程标识符

      用于唯一标识一个进程

      - 外部标识符：方便用户对进程访问，由创建者提供
      - 内部标识符：为了方便系统对进程的调用，每个进程唯一序号。
   
   2. 处理机状态
   
      - 通用寄存器
      - 指令计数器
      - 程序状态字psw：条件码、执行方式、中断屏蔽标志
      - 用户栈指针：栈指针指向栈顶
   
   3. 进程调度信息
   
      - 进程状态
      - 进程优先级
      - 进程调度所需其他信息
      - 事件
   
   4. 进程控制信息
   
      - 程序和数据的地址
      - 进程同步和通讯机制
      - 资源清单
      - 链接指针
   
   
   
   pcb组织形式
   
   线性方式：线性表
   
   链接方式
   
   索引方式
   
   
   
   操作系统内核功能
   
   - 支持功能
     - 中断处理
     - 时钟管理
     - 原语操作
   - 资源管理功能
     - 进程管理
     - 存储器管理
     - 设备管理
   
   

   

   

   进程通信类型
   
   1. 共享存储器系统
   
      - 基于共享数据结构的通信方式：共享某些数据结构实现信息交换。操作系统仅提供共享存储器，由用户控制，适用于少量数据传输，通讯效率低下，是低级通讯方式
      - 基于共享存储区的通信方式：将内存中一块区域划分为共享存储区，通过共享读写交换信息。实现通信的具体方式都由进程控制，与os无关。属于高级通讯方式。
   
   2. 管道通信系统
   
      - 管道本质是一个文件
      - 发送接收原语
      - 可以传送大量数据
      - 管道机制提供以下协调能力：
        - 互斥
        - 同步
        - 确定对方是否存在：确定后才可以相互通信
      - 管道的限制
        - 是固定的缓冲区，固定大小
        - 读进程运行较快
        - 半双工
   
   3. 消息传递系统
   
      在该机制下进程不需要任何共享存储区或数据结构而是以格式化消息单位传递信息，利用操作系统提供的通信原语完成
   
      该方式隐藏了通信细节，对用户透明化，降低通信设计的复杂度，应用最为广泛。在计算机网络中称为报文。在微内核与服务器的通信都用这个机制。属于高级通信方式

      - 直接通信方式：发送程序利用操作系统原语直接发送给接收程序
      - 间接通讯方式：发送和接收进程通过共享中间实体（称为邮箱）完成通信
   
   4. 客户机-服务系统
   
      - 套接字：套接字是一个通信标识类型的数据结构
   
        - 基于文件型，类似管道
        - 基于网络型，监听某个端口
   
        优势在于适用于同一台计算机内的进程通信，也适用于网络环境中不同计算机的通信
   
      - 远程过程调用和远程方法调用
   
        远程过程函数调用是一个通信协议，用于通过网络连接系统
   
        远程调用的步骤
   
        - 本地调用者以一般方式调用远程过程在本地关联的客户存根，传递相应参数，然后将控制权给客户存根
        - 客户存根执行，完成包括过程名和调用参数等消息的消息建立，将控制权交给本地客户进程
        - 本地客户进程完成与服务器的信息传递，将信息发送到远程服务器
        - 远程服务器进程接收信息后转入执行，并根据其中的远程程序名找到对应的服务器存根
        - 该服务器存根获得控制权运行，将结果打包为消息，并将控制权转给远程服务进程
        - 远程服务进程将消息发送回客户端
        - 本地客户端进程接收消息后，根据其中的过程名将消息存入关联的客户存根，再将控制权转移给客户存根
        - 客户存根从消息中取出结果，返回给本地调用者进程，完成控制权的转移
   
   
   
   
   
   直接消息传递系统
   
   1. 直接通信原语
      - 对称寻址方式：双方需要显式提供对方标识符，一旦改变名称则找不到
      - 非对称寻址方式：在接收进程中不需要指定发送发，接收所有消息
   2. 消息格式
   3. 同步
      - 发送进程阻塞，接收进程阻塞
      - 发送进程不阻塞，接收进程阻塞（最广泛）
      - 都不阻塞
   4. 通信链路
      - 单向
      - 双向

   

   信箱通信
   
   属于间接通信方式，可以实时或非实时
   
   
   
   
   
   线程
   
   引入线程的目的是减少程序在并发执行时的时空开销
   
   进程的基本属性
   
   - 可拥有独立资源的基本单位
   - 可独立调度和分派的基本单位

   

   进程并发时需要的时空开销
   
   - 创建进程：分配除处理机外所有资源
   - 撤销进程：对占有资源回收
   - 切换进程：保存当前cpu环境，设置新的cpu环境
   
   进程是资源的拥有者，因此在创建、撤销和转换时系统开销较大。
   
   
   
   
   
   线程作为调度和分派的基本单位
   
   
   
   线程特点
   
   - 调度的基本单位，在传统计算机中，若没有线程，则进程是调度的基本单位。在线程切换时仅需保存和设置少量寄存器的内容，切换代价远远低于进程。在同一进程中，线程切换不会引起进程切换。从一个进程的线程切换到另一个进程的线程中会引起进程切换	
   - 并发性：不同进程可以并发，一个进程中的不同线程也可以并发，不同进程的线程中也可以并发
   - 拥有资源：线程不拥有系统资源，只拥有可以保证独立运行的资源。线程共享该进程的资源。同一进程的所有线程都具有相同的地址空间，线程可以访问这个地址空间中的任意虚地址。
   - 独立性：一个线程的堆栈可以被其他线程修改、清除
   - 系统开销：
   - 支持多处理机系统：一个进程中的不同线程可以分配到不同处理机中
   
   
   
   线程的状态
   
   - 执行
   - 就绪
   - 阻塞
   
   

   线程控制块
   
   - 线程标识符
   - 一组寄存器，包括程序计数器PC、状态寄存器、通用寄存器
   - 线程运行状态
   - 优先级
   - 线程专属存储区，用于线程切换时保存现场信息，和与线程执行相关的统计信息
   - 信号屏蔽
   - 堆栈指针，每个线程设置一个堆栈。有用户自己的堆栈和核心栈
   
   
   
   多线程os的进程属性
   
   - 仍是系统资源分配的基本单位
   - 多个线程可并发执行
   - 不是可执行的实体，进程的执行状态是其中某些线程的执行状态
   
   
   
   内核级线程的优点
   
   - 在多处理器处理器上，可以同时调度同一进程中的多个线程并行执行
   - 一个线程被阻塞了内核可以调度其他线程
   - 内核线程切换开销小
   - 内核本身可以使用多线程技术，提高执行速度
   
   内核级线程的缺点：
   
   - 切换线程时需要从用户态到内核态，开销较大
   
   
   
   用户级线程的优点
   
   - 线程切换不需要到内核空间，节省开销
   - 调度算法可以是进程专用的
   - 与操作系统无关
   
   用户级线程的缺点
   
   - 系统调用阻塞
   - 无法利用多处理机的优点
   
   
   
   组合方式
   
   
   
   。。。
   
   
   
   多线程模型
   
   1. 多对一
   
      多个用户级线程映射到一个内核级线程，这些线程属于一个进程，线程调度由用户完成，仅当使用内核时映射到内核
   
      优点
   
      - 线程管理在用户空间中，效率较高
   
      缺点
   
      - 若一个线程在访问内核发生阻塞，则整个进程都会发生阻塞；任何时候都只允许一个线程访问内核，多个线程不能在多处理机上运行
   
   2. 一对一模型
   
      每个用户级线程映射到一个内核线程
   
      优点
   
      - 当一个线程阻塞后可以调度另一个线程运行，并发能力强
   
      缺点
   
      - 开销较大
   
   3. 多对多模型
   
      n个用户级线程映射到m个内核级线程中，n>m
   
      拥有上述的优点
   
   
   
   判断语句是否可以并发执行
   
   
   $$
   R(S_1) \cap W(S_2) = \emptyset \\
   
   W(S_1)\cap S(S_2) = \emptyset \\
   
   W(S_1)\cap W(S_2) = \emptyset
   $$
   
   
   
   
   
   
   例如
   
   
   $$
   S_1: \ a  = x + 1 \\
   S_2: \ b = 8 + 4 \\
   \\
   W(S_1) = \{a\} \\
   W(S_2) = \{b\} \\
   R(S_1) = \{x\} \\
   R(S_2) = \emptyset \\
   \\
   R(S_1) \cap W(S_2) = \emptyset \\
   
   W(S_1)\cap S(S_2) = \emptyset \\
   
   W(S_1)\cap W(S_2) = \emptyset
   $$
   
   
   
   
   
   
   
   # 处理机调度与死锁
   
   高级调度：作业调度
   
   中级调度：内存调度
   
   低级调度：进程调度
   
   
   
   对于优先级调度算法，io型作业的优先级应该高于cpu型作业，因为io操作需要及时完成，没办法长时间保存输入输出数据
   
   
   
   不能进行进程调度的时机
   
   - 处理中断过程中
   - 进程在操作系统**内核**临界区
   - 在原子操作过程中
   
   
   
   
   
   
   
   作业调度算法
   
   
   
   FCFS
   
   本算法既可以调度作业也可以调度进程
   
   
   
   SJF
   
   缺点
   
   - 需要预知作业时间
   - 对长作业不利
   - 采用FCFS时无法实现人机交互
   - 没有考虑作业的紧迫性
   
   
   
   HRRN
   
   
   
   进程调度算法
   
   
   
   RR
   
   
   
   优先级有动态与静态
   
   
   
   使用多级反馈调度算法需要考虑
   
   - 就绪队列数量
   - 就绪队列优先级
   - 各个就绪队列的调度算法
   - 进程在就绪队列间的迁移算法
   
   
   

可重用资源：可供用户重复多次使用

- 不允许进程共享
- 有使用顺序
  - 请求资源
  - 使用资源
  - 释放资源
- 重用资源相对固定，进程运行时不能创建或撤销



可消耗资源：由进程动态创建和撤销

- 在进程运行期间动态变化
- 可以被进程创建
- 不需要归还

进程间的通信消息是可消耗资源



死锁起因

- 竞争不可抢占资源
- 竞争可消耗资源
- 进程顺序不当



死锁产生的必要条件

- 互斥
- 请求和保持
- 不可抢占
- 循环等待



安全状态一定不会发生死锁，不安全状态只是系统可能发生死锁，不一定会有死锁



预防死锁

破坏请求和保持条件

第一种协议

在进程开始前一次性申请全部所需资源。缺点资源浪费、饥饿



第二种协议

进程获取初期运行所需资源，在运行过程逐步分解自己，当自己的资源用尽再请求新的所需资源



PV操作是低级进程通信原语



# 存储器管理



绝对装入模式

​	只适用于单道模式

可重定位转入方式

​	又成为静态重定位

动态运行时装入方式

​	需要重定位寄存器支持

​	

装入时对目标程序的指令和数据地址的修改过程成为重定位



静态链接

- 对相对地址修改
- 变换外部调用符号

装入时动态链接

- 便于修改与更新
- 便于实现目标模块共享

运行时动态链接



连续分配存储管理

​	单一连续分配

​		在单道环境下，一个程序占用整个用户空间

​	固定分区分配

​		在多道环境下，每个分区装入一个作业

​		划分分区方式

​			分区大小相等

​				缺乏灵活性，当程序太小造成浪费，程序太大无法装入，用于一个计算机同时控制多个相同装置时

​			分区大小不同

​				使用分区表，将分区排队

​	动态分区分配

​	动态分配的数据结构

​		用来描述空闲分区和已分配分区

​				空闲分区表：记录分区号，分区大小，起始地址

​				空闲分区链：双向链表

​		动态分区分配主要操作是分配和回收内存



动态分区算法

- 首次适应算法：空闲分区链地址递增，每次从头开始；留下很多碎片，开销大
- 循环首次适应：不从头开始，留下很多碎片
- 最佳适应算法：空闲分区链大小从小到大，留下很多碎片
- 最坏适应算法：缺乏大空闲分区



基于索引搜索的动态分区分配算法

​	因为空闲分区链可能很长

- 快速适应算法：将分区大小分类，每个分类有一个分区链，内存中设立一张管理索引表，每个索引表项对应一种类型。在分配时不会分割分区，不产生内部碎片，查找效率高。缺点在为了有效合并分区，算法复杂，一个分区属于一个进程。
- 伙伴系统：
- 哈希算法：建立以空间大小为关键字的哈希算法去找到分区



动态可重定位分区分配算法

1. 紧凑
2. 动态重定位
3. 动态重定位分区分配算法



对换

​	当进程阻塞时将其换出去



对换的目标

​	把磁盘空间分为文件区和对换区

- 对文件管理的主要目标

  提高文件存储空间利用率，采用离散分配

- 对对换空间的目标

  对换空间占磁盘小部分，主要为提高换入换出速度，采取连续分配



页管理

​	页表大多驻留在内存，设置页表寄存器，进程未执行时，页表的起始地址和页表的长度存放在进程的pcb中，当调度进程时，才将这两个数据填入页表寄存器中，因此在单机处理器下只需一个页表寄存器



分段的作用

- 方便编程
- 信息共享
- 信息保护
- 动态增长
- 动态链接

为每个进程建立段表



分页与分段的区别

- 页是信息的物理单位。分页是系统行为，对用户不可见。分段是信息的逻辑单位
- 页的大小由系统决定，由硬件实现。段由用户决定，在编译时划分
- 分页的地址是一维的，分段地址是二维的



信息共享

- 分页

- 分段



可重入代码，纯代码：各个进程执行结果一致，不允许进程对它进行修改



段页的好处

便于实现、分段可共享、易于保护、可动态链接



动态重定位是在作业执行过程中

覆盖技术用于单一连续存储管理和固定分区分配

内存保护是操作系统的内存管理的一部分，但必须由硬件实现，是双方的任务

在段页存储中每个进程一张段表，每个段一张页表

覆盖与交换技术的目的是节省主存空间

正在进行io操纵的进程不能被交换出主存

页表的起始地址存放在寄存器中

分段管理有利于程序动态链接

对主存的访问以字节或字为单位

将逻辑地址转为物理地址的过程叫地址重定位

分页是一维的，段是二维的

最佳适应性算法产生的碎片最多



**伙伴系统**

互为伙伴系统的两个块仅有一位物理地址不同

在并行系统常用



# 虚拟存储器



引入原因：扩充逻辑内存



常规存储器特征

- 一次性：将作业全部装入内存后才可以运行
- 驻留性：装入内存后不会被换出



局部性原理前提

- 除了少部分转移和过程调用，大部分情况下是顺序执行的
- 调用过程的深度不超过5
- 程序存在许多循环结构



时间局限性：某条指令被执行后不久可能会被再次执行；数据被访问后可能又被访问。原因是存在大量循环

空间局限性：程序访问某个存储单元后，其附近的存储单元也可能被访问。典型情况是程序顺序执行





虚拟存储器特征

- 多次性：一个进程的被分成多个部分多次调入内存。最重要特征
- 对换性：允许在作业运行时换入换出
- 虚拟性：能够在逻辑上扩展内存



分页请求系统：在分页系统上增加请求调页功能和页面置换功能，系统提供硬件和请求分页软件支持

1. 硬件支持
   - 请求分页的页表机制：在纯分页的页表机制上增加若干项
   - 缺页中断机构：产生缺页中断
   - 地址变换机构

请求分段系统



- 状态位P（合法位）：指示是否调入内存，决定是否发生页故障
- 访问字段A：记录被一段时间内访问的次数
- 修改位M：是否被修改过
- 外存地址：指示该页在外存的地址



缺页中断是在指令执行期间，一条指令在执行期间可能产生多条缺页中断



请求分页内存分配

1. 保证程序正常运行，确定最小物理块
2. 内存分配策略
   - 固定分配局部置换：为每个进程分配固定大小物理块，运行期间不改。若缺页，则从这些页面中选一页换出去。
   - 可变分配全局置换：可以从系统空闲页面分配给缺页进程
   - 可变分配局部置换：若进程频繁缺页，就附加空闲页面
3. 物理块分配算法
   - 平均分配算法：不同大小的进程造成分配不均与
   - 按比例分配算法：
   - 考虑优先权的分配算法：将物理块分两部分，一部分按比例分配，另一部分根据优先级分配



何时调入页面

- 预调入策略：许多页存放在外存连续区域中，一次调入若干个相邻页。

- 请求调页策略：当缺页时便调入



从何处调入页面

- 系统拥有足够的对换区，可以全部从对换区调入所需页面，以便提高页面速度。在进程运行前，便将与该进程有关的文件从文件区拷贝到对换区
- 系统缺少足够的对换区：凡是不会被修改的文件，都直接从文件区调入。对于可能被修改部分，需要调入对换区
- unix方式：



最佳置换算法



最近最久未使用算法

硬件支持

- 寄存器：是移位寄存器，每隔一段：时间右移一位，选取最小的页面换出
- 栈：

实现复杂因为需要排序



最少使用置换算法

设置移位寄存器记录页面被访问频率



简单clock算法

设置访问位，当被访问时设置为1。淘汰时若访问位为1，则设置为0，若为0，则换出，又称为最近未用算法



改进clock算法

先置换出未使用过、未修改过的页面置换出去

1. 先淘汰A = 0，M = 0
2. 在淘汰A = 0, M = 1
3. 将所有将A置为0，重复第一步，再重复第二步



发生抖动的根本原因：在系统中运行的进程太多，分配给物理块太少，主要原因是页面置换算法不合理





虚拟存储器实现方法

- 请求调页（段）
- 页（段）置换



请求分段

- 存取方式：保护方式，只执行、只读、允许读写
- 访问字段A：记录被访问的频繁程度
- 修改位M：
- 存在位P：是否本段在内存中
- 增补位：特有字段，本段是否做过动态增长
- 外存始址：



缺段中断机构





共享段表

系统配置一张共享段表

- 共享进程计数：当计数为0时才回收
- 存取控制字段：为不同进程赋予不同存取权限
- 段号：在不同进程中可以有不同段号，每个进程用自己的段号去访问该共享段



共享段的分配

若内存中已经存在该段，只需要计数加一，在共享段表中增加一个表项，填上进程名、该共享段在本进程中的段号、存取控制



分段保护

- 越界检查：通过地址变换机构完成的，设置段表寄存器
- 存取检查控制：
- 环保护机构：一个程序可以访问驻留在相同环或较低特权的数据；一个程序可以调用驻留在相同环或较高特权环中的服务





# 文件管理



文件类型

1. 按用途分

   - 系统文件

   - 用户文件

   - 库文件

2. 按数据形式

   - 源文件
   - 目标文件
   - 可执行文件

3. 按存储控制属性分类

   - 只执行文件
   - 只读文件
   - 读写文件

4. 按组织形式和处理方式

   - 普通文件
   - 目录文件
   - 特殊文件



文件系统模型

- 文件系统接口
- 对对象操纵和管理的软件集合
- 对象及其属性



文件管理对象

- 文件
- 目录
- 磁盘存储空间



对对象操纵和管理的软件集合

- 对文件存储空间的管理
- 对文件目录的管理
- 用于将文件的逻辑地址转换为物理地址的机制
- 对文件的读和写管理
- 对文件的共享与保护等功能

与文件系统有关的软件分为四个层次

- io控制层，文件系统的最底层，也称为设备驱动程序层
- 基本文件系统层，主要用于处理内存与磁盘之间的数据块的交换
- 基本io管理程序
- 逻辑文件系统



文件系统的接口

- 命令接口：用户与文件系统直接交互，从键盘输入终端输入
- 程序接口：系统调用





文件的逻辑结构：从用户观点出发所观察到的文件组织，即文件文件是由一系列的逻辑记录组成，称为文件组织

文件的物理结构：



有结构文件

1. 定长文件
2. 变长文件

无结构文件



顺序文件：记录是定长的或可变长记录

索引文件：为可变长记录建立一张索引表

索引顺序文件：问每个文件建立索引表，只记录一组记录中的第一个记录



顺序文件的排列方式

- 串结构：通常按存入时间的先后排序，每次都从头检索
- 顺序结构：由用户指定一个字段作为关键字，具有唯一性，可以用特定检索算法提高检索效率

顺序文件的优缺点

适合对文件记录进行批量处理，存储效率最高

查找效率低

增加或删除困难，解决方法是配置运行记录文件或称为事物文件



隐式寻址方式：

对于定长文件设置读指针和写指针



显示寻址：





索引文件





fbc

1. 基本信息

   - 文件名：唯一的

   - 文件的物理位置

   - 文件的逻辑结构

   - 文件的物理结构

2. 存取控制信息

   文件主的存取权限、核准用户的存储权限、一般用户的存储权限

3. 使用信息类

   文件的创建时间、文件上次修改时间



目录查询技术

- 线性检索
- 哈希



外存的组织方式



连续组织方式

优点

- 顺序访问容易
- 顺序访问速度快

缺点

- 要求为文件连续分配连续存储空间，产生许多外部碎片
- 必须事先知道文件长度
- 不能灵活删除和插入
- 对于动态增长的文件难以分配存储空间





链接组织方式

用每个盘块上的链接指针链接

优点

- 消除外部碎片，提高外存利用率
- 对插入、删除、修改都很容易
- 能够适应文件的动态增长



链接方式分为隐式链接和显式链接

隐式链接

在文件目录的每个目录项中，都存在指向第一个和最后一个盘块的指针，每个盘块有指向下一个盘块的指针

只适合顺序访问，随机访问效率低

为了提高检索速度，可将若干盘块组成一个簇，但增大了内部碎片



显示链接

将链接各个盘块的指针显示放在一张链接表中，链首地址填入fcb中

提高检索速度，减低访问磁盘访问次数

表叫文件分配表fat



单级索引组织方式

链接方式出现的问题

- 不支持高效存取，对大文件需要顺序查找很多盘块
- fat占用的内存空间较大

索引优点

- 支持直接访问
- 不会产生外部碎片



多级索引组织方式

- 加快大型文件的查找碎度
- 降低小型文件查找速度



增量式索引组织方式（混合组织方式）



# io



块设备接口

- 块设备：数据的存取与传输是以数据块为单位的设备，如磁盘。速度较高，可寻址，随机读写
- 隐藏了磁盘的二维结构
- 将抽象命令映射为低层操作



流设备接口

流设备程序与高层之间的接口，又称字符设备接口

1. 字符设备：数据存取和传输以字符为单位的设备，字符设备传输效率低，不可寻址
2. get和put操作，由于字符设备不可寻址，因此只能顺序存取方式
3. in-control指令：通用in-control指令

大多数流设备属于独占设备，需要互斥方式共享





按特性分类

- 存储设备：外存、辅存
- io设备：输入输出设备，交互设备，入键盘、鼠标



按传输速率分类

- 低速设备：键盘鼠标
- 中速设备：打印机
- 高速设备：磁带机、光盘机



io设备与控制设备间的接口

- 数据信号线：对与输入设备，外界数据先存放缓存区，当达到一定后，从数据信号线传送给控制设备。
- 控制信号线：
- 状态信号线



设备控制器的基本功能

- 接收和识别命令
- 数据交换
- 标识和报告设备状态
- 地址识别
- 数据缓冲区
- 差错控制





设备控制器的组成

1. 设备控制器







使用轮询的io设备控制方法

控制器向io控制设备发出io指令，启动输入设备输入数据时，同时要把状态寄存器的忙\闲标志置为1，表示正在忙，然后不断循环测试，，当为1时表示输入机没完成一个字符输入，当为0是表示完成一个字符的输入，接下来读取下一个数据

这种方式cpu绝大多数时间在等待io设备完成数据io的循环测试中，因为io无法向cpu报告是否完成



使用io中断

cpu向设备控制器发送io命令，立即返回执行其他任务。当io设备完成后向cpu发送中断



直接存储器访问方式

io中断方式是以字节为单位

- 数据传输单位是数据块
- 传送是从设备直接送入内存的
- 整块数据传输不需要cpu



dma控制器中的寄存器

- 命令/状态寄存器cr：接收cpu的io命令、关键控制信息、设备状态
- 内存地址寄存器mar：存放输入的内存目标地址或输出的内存源地址
- 数据寄存器dr：暂存数据
- 数据计数器dc：存放本次要传输的数据的字节数



mda工作流程

- 设置mar和dc的初始值
- 启动dma传送命令
- 挪用存储器周期传送数据
- 存储器地址加一，数据计数寄存器减一
- 判断dc是否为零
- 是则请求中断，否则准备传送下一字节





io通道控制方式

每次使用dma时只能连续传输一个数据块

io通道将对一个数据块为单位的干预减少为对一组数据块，实现cpu、通道、io设备三者并行



通道程序

通道通过通道程序与设备共同实现对io设备的控制的

- 操作码：规定指令执行的操作
- 内存地址：数据在内存中的首地址
- 计数：本条指令传输的字节数
- 通道程序结束位P：表示通道程序是否结束
- 记录结束标志R：0表示本通道程序指令与下一条指令所处理的数据是同属一个记录；1表示这是处理某记录的最后一条指令





设备分配的数据结构

设备控制表dct

为每个设备配置了一张设备控制表

设备分配表字段

- 设备类型
- 设备标识符
- 设备队队列首指针：凡是因为请求本设备但没有满足的进程，将其pcb按一定策略排成一个设备申请队列，本字段指向队首pcb
- 忙/闲标志：表示当前设备是忙还是闲
- 与设备连接的控制器表指针：
- 重复执行次数：由于外部设备在传输数据较容易发生错误，发成错误则重传，超过次数则传输失败



控制器控制表coct：系统为每个控制器设置用于记录控制器情况的控制器控制表

- 控制器标识符
- 控制器状态
- 与控制器连接的通道表指针
- 控制器队列的队首指针
- 控制器队列的队尾指针

通道控制表chct：每个通道有一张通道控制表

- 通道标识符
- 通道状态
- 与通道连接的控制器表首址
- 通道队列的队首指针
- 通道队列的队尾指针

系统设备控制表sdt：记录了系统全部的设备的情况，每个设备占一个项目

- 设备类
- 设备标识符
- dct
- 驱动程序入口



分配设备

1. 考虑因素设备固有属性

   - 独占设备分配：分配后由该进程独占，直到进程释放

   - 共享设备：注意进程访问的先后次序

   - 虚拟设备：虚拟设备属于共享设备，可同时分配给多个进程设备

     

     2. 分配算法

   - 先来先服务

   - 优先级高优先

     

     3. 设备分配安全性

     安全分配方式：当进程发出io请求后便进入阻塞状态，知道io操作完成才被唤醒，摒弃了请求和保持条件

     不安全分配：io请求不阻塞，仅当被请求的io设备被占用阻塞



对独占设备分配

基本的分配程序

- 分配设备：根据io请求中物理设备名查找sdt，在找到dct，根据dct中的设备状态字段判断是否忙，若忙则挂pcb在队列上，然后检查分配的安全性，若安全则分配，否则挂在队列上
- 分配控制器：在将设备分配后，在设备的dct中找到其控制器的coct，从coct中的状态字段判断控制器是否繁忙，若忙则将pcb挂在队列上，否则分配控制器
- 分配通道：在coct中找到与其连接的通道chct，根据chct的状态位判断是否在忙，若忙，挂在等待队列上，否则分配通道

三者都分配成功则分配成功



设备分配改进：应该使用逻辑设备名，当一个设备不可用，可以找同逻辑的设备，有一个则可以分配



逻辑设备表

- 逻辑设备名
- 物理设备名
- 设备驱动程序入口地址



设置逻辑设备表的方式

一个系统一张：不能yoga相同逻辑名，适用于单用户

一个用户一张





spooling技术

将一台物理io设备虚拟为多台逻辑io设备，让多个用户共享

假脱机技术：为了缓和cpu与io速度不匹配引入脱机输入输出技术，利用专门的外围机将io设备上的数据传送到高速磁盘上，处理机要读取则可以直接从磁盘读取



spooling技术组成

它是对脱机输入输出技术的模拟，建立在通道技术和多道程序技术上的，以高速外存为后援的技术

- 输入井、输出井：在磁盘上开辟的两个存储区域，输入井模拟脱机输入的磁盘，用于收容io设备输入的数据；输出井模拟脱机输出的磁盘，接收用户程序输出的数据。数据以文件方式组织
- 输入缓冲区、输出缓冲区：在内存中开辟的缓冲区，用于缓解cpu与磁盘速度不匹配。输入缓冲区暂存由输入设备传送的数据，之后在传送到输出井；输出缓冲区用于暂存从输出井传送的数据，之后传送到输出设备
- 输出进程和输入进程：输入进程也成为预输入进程，模拟外围控制机，将数据从输入设备输入输入缓冲区；当cpu需要输入设备时直接从输入井读入内存。输出进程成为缓输出进程，把用户数据从内存传送到输出井，等输出设备空闲，在将输出井的数据经过输出缓冲区输出到输出设备
- 井控制程序：用于控制作业与磁盘之间的信息交换

spooling技术的特点

- 提高io速度，将低速io操作变为对磁盘缓冲区数据的读取
- 将独占设备改为共享设备：因为在假脱机中，没有为任何进程分配设备，而只是在磁盘缓冲区为进程分配一个空闲盘块和建立一张io请求表
- 实现了虚拟设备的功能，虽然多个进程都在使用一个独占设备，但对每个进程都认为自己独占设备



引入缓冲区的原因

- 缓解cpu与io速度不匹配
- 减少cpu中断频率，放宽对cpu中断响应时间的限制
- 解决数据粒度不匹配问题
- 提高cpu与io的并行性



单缓冲区

每发出一个io请求申请一个缓冲区

- io设备将数据输入缓冲区，时间为T
- 缓冲区将数据传送到用户工作区，时间为M
- 用户处理数据，时间为C

由于1，3步骤可以并行因此处理每一块数据的时间为max{T,C} + M



双缓冲区

io设备可以将数据装入第一缓冲区或第二缓冲区，缓冲区满后输入用户工作区

处理一块数据的时间约为max{C, T}















